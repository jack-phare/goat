# Langfuse Observability

Langfuse traces all LLM calls — cost, latency, tokens, full I/O. It hooks into LiteLLM callbacks with zero changes to the Go agent code.

## How It Works

LiteLLM sends trace data on every completion via `success_callback: ["langfuse"]` and `failure_callback: ["langfuse"]` in the config. The Go binary is unaware of Langfuse.

## Local Setup

Runs as part of the Docker Compose dev stack. Auto-provisioned, no manual setup.

```bash
docker compose --env-file .env -f dev/docker-compose.yml up -d
open http://localhost:3001
```

| Field | Value |
|-------|-------|
| URL | `http://localhost:3001` |
| Email | `admin@goat.local` |
| Password | `admin1234` |
| Public Key | `pk-lf-goat-dev` |
| Secret Key | `sk-lf-goat-dev` |

LiteLLM connects via internal Docker network:

```yaml
LANGFUSE_PUBLIC_KEY=pk-lf-goat-dev
LANGFUSE_SECRET_KEY=sk-lf-goat-dev
LANGFUSE_HOST=http://langfuse:3000
```

## Modal Setup

Langfuse runs in the `goat-services` app with **co-located Postgres** (Modal only proxies HTTP, not TCP — so Postgres must be localhost inside the container). Data persists on the `goat-langfuse-pg` volume.

```bash
modal deploy scripts/modal_services.py --env goat
modal app logs goat-services    # find the URL
```

URL: `https://<workspace>--goat-services-langfuse.modal.run`

The custom image (`scripts/Dockerfile.langfuse`) bundles Langfuse v2 + Postgres + Node.js + Prisma on Alpine. On first boot it copies a template data dir to the volume, then runs migrations.

LiteLLM discovers Langfuse via internal URL (`http://goat-services-langfuse.modal.internal`) with public URL fallback, waiting up to 45s for health check.

## Verifying Traces

```bash
# Fire test call + verify trace arrives
uv run --with modal,requests python scripts/verify_langfuse_traces.py

# Specific model
uv run --with modal,requests python scripts/verify_langfuse_traces.py --model llama-3.1-8b-local

# Query-only (no test call)
uv run --with modal,requests python scripts/verify_langfuse_traces.py --query-only

# Include raw Postgres SQL
uv run --with modal,requests python scripts/verify_langfuse_traces.py --sql
```

## Querying Postgres Directly

```python
import modal
fn = modal.Function.from_name("goat-services", "langfuse_query", environment_name="goat")

print(fn.remote(sql="SELECT count(*) FROM traces;"))
print(fn.remote(sql="SELECT id, name, created_at FROM traces ORDER BY created_at DESC LIMIT 10;"))
dump = fn.remote(dump=True)  # full pg_dump
```

## Syncing Modal Traces to Local

```bash
bash scripts/langfuse_sync_local.sh          # full sync
bash scripts/langfuse_sync_local.sh --open   # sync + open browser
bash scripts/langfuse_sync_local.sh --dump-only  # just download dump
```

After syncing, view at `http://localhost:3001` with local credentials.

## Modal Secret (`goat-langfuse`)

Created by `modal_setup.py`:

```
LANGFUSE_INIT_ORG_ID=goat
LANGFUSE_INIT_PROJECT_ID=goat-evals
LANGFUSE_INIT_PROJECT_PUBLIC_KEY=pk-lf-goat-modal
LANGFUSE_INIT_PROJECT_SECRET_KEY=sk-lf-goat-modal
LANGFUSE_INIT_USER_EMAIL=admin@goat.local
LANGFUSE_INIT_USER_PASSWORD=<auto-generated>
LANGFUSE_NEXTAUTH_SECRET=<auto-generated>
LANGFUSE_SALT=<auto-generated>
```
